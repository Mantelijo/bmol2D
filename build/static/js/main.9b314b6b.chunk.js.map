{"version":3,"sources":["lib/types/atoms.ts","Store.tsx","lib/AtomsFunctions.tsx","lib/types/interactions.ts","lib/InteractionsFinder.ts","components/Viewer.tsx","lib/PDBHandler.ts","components/DataFetcher.tsx","components/Spinner.tsx","App.tsx","reportWebVitals.ts","index.tsx"],"names":["AtomRemoteness","DNAResidues","RNAResidues","ProteinResidues","PolymerKind","initialState","polymers","pdb","undefined","isLoading","simpleStuffy","hashedNucleicAcidResidues","viz","chain1","chain2","context","createContext","reducer","state","type","payload","Error","StoreComponent","children","useReducer","dispatch","Provider","value","calculateCenters","p","residues","forEach","residue","i","coordinate","x","y","z","atoms","atom","coords","length","center","distanceBetween2Points","p1","p2","Math","sqrt","pow","ResidueMetaFromResidue","r","sequenceNumber","hash","name","polymerChainIdentifier","isWatsonCrickPair","r1","r2","DA","DT","DC","DG","InteractionType","InteractionsFinder","nucleicAcids","proteins","visualization","this","prepareObjects","findNucleoAcids","findProteins","polymer","filter","Protein","indexOf","kind","DNA","RNA","first","second","distancesFirst","Array","fill","Infinity","i1","i2","min","currentIndex","secondChainIncludedAmount","res1","j","res2","newRes2","push","index","interactions","console","log","nacid","nacidI","nacidResidue","nacidResidueI","pResidue","THRESHOLD_DISTANCE","nacidAtom","pAtom","distanceAtoms","Threshold","polymerKind","meta","distance","Viewer","useContext","ref","React","createRef","tooltip","map","useEffect","ColorMap","GetColor","d3","current","selectAll","remove","visualizationData","generateVisualizationScaffold","nucleoAcidsData","data","chainId","visualizationResidue","maxResidues","max","numAcids","yScale","domain","range","h","xScale","w","tooltipEl","svg","attr","enter","append","a","style","on","event","b","interactionsHtml","html","transition","duration","pageX","pageY","end","className","position","opacity","background","PDBHandler","file","text","format","raw","formatText","formatPolymers","split","line","toString","join","result","newPolymer","chainIdentifier","Unknown","pushResidue","currentResidue","currentPolymer","determinePolymerKindAndReset","c","obj","Object","keys","reduce","currentPolymerKindCounter","startsWith","parseFloat","slice","trim","residueName","element","residueSequenceNumber","parseInt","polymerKindFromAtom","fetchPDBFile","id","fetch","response","pdbText","DataFetcher","startLoading","stopLoading","updatePDBState","updatePolymers","iFinder","thresholdInteractions","URLSearchParams","window","location","search","get","handleFileChange","f","target","files","item","time","readData","timeEnd","setTimeout","readOnly","onChange","k","key","Spinner","App","backgroundColor","AppWrapper","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.9b314b6b.chunk.js","sourcesContent":["/**\r\n * Formats of spatial data for visualization\r\n */\r\n\r\nimport { Interaction } from \"./interactions\";\r\n\r\n// Coordinate represents a 3-dimensional coordinate set\r\nexport type Coordinate = {\r\n    x: number,\r\n    y: number,\r\n    z: number, \r\n}\r\n\r\n// Structure for ATOM records in pdb file\r\nexport interface Atom{\r\n    coords: Coordinate,\r\n    name: string,\r\n    residueName: ResidueName,\r\n    element: string,\r\n    residueSequenceNumber: number,\r\n}\r\n\r\n/**\r\n * Atom names might contain remoteness symbols. Here is a small mapping up to H\r\n * \r\n * @example AtomRemoteness[\"A\"]\r\n */\r\nexport enum AtomRemoteness {\r\n    A='α',\t\r\n    B='β',\t\r\n    G='γ',\t\r\n    D='δ',\t\r\n    E='ε',\t\r\n    Z='ζ',\t\r\n    H='η',\t\r\n}\r\n\r\nexport type ResidueName = string | DNAResidues | RNAResidues | ProteinResidues;\r\n\r\n// Met information about residue, not helpful for calculations\r\nexport interface ResidueMeta{\r\n    hash: string,\r\n    name: ResidueName,\r\n    sequenceNumber: number,\r\n    polymerChainIdentifier: string,\r\n    // polymerKind: PolymerKind,\r\n}\r\n\r\n/**\r\n *  @see https://proteopedia.org/wiki/index.php/Standard_Residues\r\n */\r\nexport interface Residue extends ResidueMeta{\r\n    // Center defines the arithmetic average of all atoms coordinates in residue\r\n    // All coordinates are set to -1 if center is not calculated\r\n    center: Coordinate,\r\n\r\n    // List of interactions with this residue\r\n    interactions: Interaction[],\r\n\r\n    // Residue atoms\r\n    atoms: Atom[],\r\n}\r\n\r\n/**\r\n * Residue types for DNA, RNA and Proteins\r\n * DNA - deoxynucleotides\r\n * RNA - nucleotides\r\n * PROTEIN - standard amino acids\r\n */\r\nexport enum DNAResidues{\r\n    DA = \"DA\",\r\n    DG = \"DG\",\r\n    DC = \"DC\",\r\n    DT = \"DT\",\r\n}\r\n\r\nexport enum RNAResidues{\r\n    A, C, G, I, U\r\n}\r\nexport enum ProteinResidues{\r\n    Ala, Arg, Asn, Asp, Cys, Glu, Gln, Gly, His, Ile, Leu, Lys, Met, Phe, Pro, Ser, Thr, Trp, Tyr, Val,\r\n}\r\n\r\n/**\r\n * Type of polymer\r\n */\r\nexport enum PolymerKind {\r\n    DNA =\"DNA\",\r\n    RNA = \"RNA\",\r\n    Protein = \"Protein\",\r\n\r\n    // Undefined polymer kind \r\n    Unknown = \"Unknown\",\r\n}\r\n\r\n/**\r\n * Polymer contains all residues until a TER in PDB is found\r\n */\r\nexport interface Polymer{\r\n    residues: Residue[],\r\n    kind: PolymerKind,\r\n    chainIdentifier: string, // Name of the chain (A,B,C, ... <etc>)\r\n}\r\n\r\n/**\r\n * File formats below\r\n */\r\nexport interface PDBFile{\r\n    polymers: Polymer[],\r\n    raw: string,\r\n}\r\n\r\n\r\n/**\r\n * Determines polymer kind from atom's residue name\r\n * \r\n * @param atom \r\n * @returns\r\n */\r\nexport function polymerKindFromAtom(atom: Atom): PolymerKind{\r\n    switch (true){\r\n        case atom.residueName in DNAResidues:\r\n            return PolymerKind.DNA;\r\n        case atom.residueName in RNAResidues:\r\n            return PolymerKind.RNA;\r\n        default:\r\n            return PolymerKind.Protein;\r\n    }\r\n}   ","import React, {createContext, useReducer, ReactElement} from \"react\";\r\nimport { Polymer, Residue } from \"./lib/types/atoms\";\r\nimport {PDBFile} from './lib/types/atoms'\r\nimport { Visualization } from \"./lib/types/visualization\";\r\n\r\n/**\r\n * Initial State object structure \r\n */\r\nconst initialState: State = {\r\n    polymers:[],\r\n    pdb: undefined,\r\n    isLoading: false,\r\n    simpleStuffy:'',\r\n    hashedNucleicAcidResidues:{},\r\n    viz: {chain1:null, chain2:null},\r\n};\r\n\r\nexport type HashedResidue = {\r\n    [key: string]: Residue\r\n}\r\n\r\n// State structure\r\nexport interface State{\r\n    polymers: Polymer[],\r\n    pdb: PDBFile | undefined,\r\n\r\n    // Determine if process is currently loading or not\r\n    isLoading: boolean,\r\n\r\n    simpleStuffy: string,\r\n\r\n    // This is used for faster lookups of nucleic acid residues. \r\n    // Since nucleic acids are the central parts of visualization,\r\n    // we might need to do many lookups, when searching for interactions.\r\n    hashedNucleicAcidResidues: HashedResidue\r\n\r\n    // Data to be visualized\r\n    viz: Visualization\r\n}\r\n\r\n/**\r\n * Actions structure\r\n */\r\nexport interface Action{\r\n    type: keyof State,\r\n    payload:any,\r\n}\r\n\r\nconst context = createContext<[State, React.Dispatch<Action>]>([initialState, ()=>{}]);\r\n\r\n// Reducer mutates the state\r\nconst reducer = (state: State, {type, payload}:Action): State => {\r\n\r\n    switch(type) {\r\n        // Default case works when type is equal state property name\r\n        default:\r\n            if (type in state){\r\n                (state as any)[type] = payload;\r\n            }else{\r\n                throw new Error(`${type} not found in state`);\r\n            }\r\n    };\r\n\r\n    // We must return new object, otherwise update won't be triggered\r\n    return {...state};\r\n}\r\n\r\n\r\ninterface Props{\r\n    children: ReactElement,\r\n}\r\n\r\nconst StoreComponent =  ({ children }:Props ) => {\r\n    const [state, dispatch] = useReducer(reducer, initialState);\r\n    return <context.Provider value={[state, dispatch]}>{children}</context.Provider>;\r\n};\r\n\r\nexport {context, StoreComponent}","/**\r\n * This file defines some helper functions which are used to \r\n * process atoms, residues, polymers and related functionality.\r\n */\r\n\r\nimport { Coordinate, DNAResidues, Polymer, Residue, ResidueMeta } from \"./types/atoms\";\r\n\r\n// Calculate centers for residues and returns same polymer with\r\n// calculated center coordinates\r\nexport function calculateCenters(p: Polymer): Polymer{\r\n    p.residues.forEach((residue, i)=>{\r\n        const coordinate: Coordinate = {\r\n            x:0,y:0,z:0\r\n        };\r\n        residue.atoms.forEach(atom=>{\r\n            coordinate.x += atom.coords.x;\r\n            coordinate.y += atom.coords.y;\r\n            coordinate.z += atom.coords.z;\r\n        });\r\n        coordinate.x = coordinate.x / residue.atoms.length;  \r\n        coordinate.y = coordinate.y / residue.atoms.length;  \r\n        coordinate.z = coordinate.z / residue.atoms.length;  \r\n\r\n        p.residues[i].center = coordinate;\r\n    });\r\n    return p;\r\n};\r\n\r\n// Calculates arithmetic distance between 2 coordinates\r\nexport function distanceBetween2Points(p1: Coordinate, p2: Coordinate): number{\r\n    return Math.sqrt(\r\n        Math.pow(p1.x - p2.x, 2) + \r\n        Math.pow(p1.y - p2.y, 2) + \r\n        Math.pow(p1.z - p2.z, 2) \r\n    );\r\n}\r\n\r\n// Helper function, since I could not find a Typescript'y way to do this\r\nexport function ResidueMetaFromResidue(r: Residue): ResidueMeta{\r\n    const {sequenceNumber, hash, name, polymerChainIdentifier}: ResidueMeta = r\r\n    return {sequenceNumber, hash, name, polymerChainIdentifier}\r\n}\r\n\r\n// Only for DNA\r\nexport function isWatsonCrickPair(r1: Residue, r2: Residue): boolean{\r\n    return (\r\n        (r1.name === DNAResidues[DNAResidues.DA] && r2.name === DNAResidues[DNAResidues.DT]) || \r\n        (r1.name === DNAResidues[DNAResidues.DT] && r2.name === DNAResidues[DNAResidues.DA]) || \r\n        (r1.name === DNAResidues[DNAResidues.DC] && r2.name === DNAResidues[DNAResidues.DG]) || \r\n        (r1.name === DNAResidues[DNAResidues.DG] && r2.name === DNAResidues[DNAResidues.DC])\r\n    );\r\n}","import { PolymerKind, Residue, ResidueMeta } from \"./atoms\";\r\n\r\n// Defines the distance threshold value for Threshold interaction type\r\nexport const THRESHOLD_DISTANCE: number = 5;\r\n\r\nexport enum InteractionType{\r\n    // Threshold based interaction. Distance is the only factor\r\n    Threshold,\r\n\r\n    // Hydrogen bond interactions\r\n    HBond,\r\n\r\n    // Watson crick pair interactions, primarily between DNA, RNA\r\n    // nucleotides (Defined by VisualizationResidue.index)\r\n    // WatsonCrickPair,\r\n}\r\n\r\n// Interaction interface defines an interaction that the residue\r\n// containing the interaction object has.\r\nexport interface Interaction{\r\n    // The residue that Interaction holder interacts with\r\n    residue: ResidueMeta,\r\n    polymerKind: PolymerKind,\r\n    type: InteractionType,\r\n\r\n    // Any additional data\r\n    meta: any\r\n}\r\n\r\n","import { DNAResidues, Polymer, PolymerKind, ResidueMeta } from \"./types/atoms\";\r\nimport {Action} from \"../Store\";\r\nimport { calculateCenters, distanceBetween2Points, isWatsonCrickPair, ResidueMetaFromResidue } from \"./AtomsFunctions\";\r\nimport { InteractionType, THRESHOLD_DISTANCE } from \"./types/interactions\";\r\nimport { Visualization } from \"./types/visualization\";\r\n\r\nexport class InteractionsFinder{\r\n\r\n    nucleicAcids: Polymer[] = [];\r\n    proteins: Polymer[] = [];\r\n\r\n    // This will be used to generate visualization\r\n    visualization: Visualization = {chain1:null, chain2:null};\r\n\r\n    constructor(\r\n        public polymers: Polymer[],\r\n        public dispatch: React.Dispatch<Action>\r\n    ){\r\n        this.prepareObjects();\r\n    }\r\n\r\n    // Finds polymers to work with, calculates centers for residues.\r\n    prepareObjects(){\r\n        this.nucleicAcids = this.findNucleoAcids();\r\n        this.proteins = this.findProteins();\r\n\r\n        this.nucleicAcids.forEach(polymer=>calculateCenters(polymer));\r\n        this.proteins.forEach(polymer=>calculateCenters(polymer));\r\n    }\r\n\r\n    findProteins(): Polymer[]{\r\n        return this.polymers.filter(p=>{\r\n            return [PolymerKind.Protein].indexOf(p.kind) !== -1\r\n        })\r\n    }\r\n\r\n    findNucleoAcids(): Polymer[]{\r\n        return this.polymers.filter(p=>{\r\n            return [PolymerKind.DNA, PolymerKind.RNA].indexOf(p.kind) !== -1\r\n        })\r\n    }\r\n\r\n    // Generates visualization.chain1 and if possible visualization.chain2\r\n    // This should be called once all required interactions are calculated\r\n    generateVisualizationScaffold(): Visualization{\r\n        if(this.nucleicAcids.length <= 0){\r\n            throw Error(\"Nucleic acids are not initialized\");\r\n        }\r\n\r\n        // DNA We assume that chains in source files (PDB, etc) appear in\r\n        // order i.e. first and second chains are from the same DNA\r\n        // strand.\r\n        if(this.nucleicAcids.length >= 2 && this.nucleicAcids[0].kind === PolymerKind.DNA){\r\n            this.visualization.chain1 = [];\r\n            this.visualization.chain2 = [];\r\n\r\n            const first = this.nucleicAcids[0];\r\n            const second = this.nucleicAcids[1];\r\n\r\n            // Smallest distances for first chain. Each item is for each\r\n            // residue.\r\n            const distancesFirst = new Array(first.residues.length).fill(+Infinity)\r\n            first.residues.forEach((r1, i1)=>{\r\n                second.residues.forEach((r2, i2)=>{\r\n                    if(isWatsonCrickPair(r1, r2)){\r\n                        distancesFirst[i2] = Math.min(distancesFirst[i2], distanceBetween2Points(r1.center, r2.center));\r\n                    }\r\n                })\r\n            });\r\n\r\n            // It looks like that usually the PDB files can contain up to\r\n            // 1 nucleotide protrusion in DNA helix. Also, it seems that DNA's\r\n            // second strand must be reversed (5'-3' -> 3'->5') when matching \r\n            // with the first strand.\r\n            \r\n            // Tracks the next index for visualization residue index property \r\n            let currentIndex = 0;\r\n\r\n            // Tracks the number of added residues from chain2, since we\r\n            // don't want to include already included chain2 residues, as\r\n            // this can happen in the inner loop\r\n            let secondChainIncludedAmount = 0\r\n\r\n            for(let i=0;i<first.residues.length;i++){\r\n                let res1 = first.residues[i];\r\n                // Second chain is reversed to 3'->5' to match first one\r\n                // We assume that chain lengths are identical (hence -1-i)\r\n                for(let j=second.residues.length-1-secondChainIncludedAmount;j>0;--j){\r\n                    let res2 = second.residues[j]\r\n\r\n                    // First residue from first chain might be a\r\n                    // protrusion, so check if j-1 might match with i\r\n                    // (Which would mean j is protrusion)\r\n                    if(!isWatsonCrickPair(res1, res2) && j-1 > 0 && i === 0){\r\n                        let newRes2 =  second.residues[j-1]\r\n                        if(isWatsonCrickPair(res1, newRes2)){\r\n                            // This case means that j is protrusion, so we\r\n                            // add it as a lonely nucleotide to chain2 \r\n                            this.visualization.chain2.push({\r\n                                index: currentIndex,\r\n                                residue: ResidueMetaFromResidue(newRes2),\r\n                                interactions: newRes2.interactions,\r\n                            });\r\n                            secondChainIncludedAmount++;\r\n                        }else{\r\n                            // i is protrusion\r\n                            this.visualization.chain1.push({\r\n                                index: currentIndex,\r\n                                residue: ResidueMetaFromResidue(res1),\r\n                                interactions: res1.interactions,\r\n                            });\r\n                        }\r\n                        \r\n                        currentIndex++;\r\n                        break;\r\n                    }\r\n\r\n                    // Valid watson crick pair\r\n                    if(isWatsonCrickPair(res1, res2)){\r\n                        this.visualization.chain1.push({\r\n                            index: currentIndex,\r\n                            residue: ResidueMetaFromResidue(res1),\r\n                            interactions: res1.interactions,\r\n                        });\r\n                        if(secondChainIncludedAmount <= second.residues.length){\r\n                            this.visualization.chain2.push({\r\n                                index: currentIndex,\r\n                                residue: ResidueMetaFromResidue(res2),\r\n                                interactions: res2.interactions,\r\n                            });\r\n                            secondChainIncludedAmount++;\r\n                        }\r\n                        currentIndex++;\r\n                        break;\r\n                    }\r\n                }\r\n                \r\n                // If chain1 is longer than chain2 - fill in the\r\n                // leftover chain1 residues\r\n                if(secondChainIncludedAmount > second.residues.length){\r\n                    this.visualization.chain1.push({\r\n                        index: currentIndex,\r\n                        residue: ResidueMetaFromResidue(res1),\r\n                        interactions: res1.interactions,\r\n                    });\r\n                    currentIndex++;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            // If chain1 is done, but chain2 is still not completely\r\n            // included, then we need to include it.\r\n            console.log(\"secondChainIncludedAmount\", secondChainIncludedAmount, second.residues.length)\r\n            if(secondChainIncludedAmount< second.residues.length){\r\n                for(let i=second.residues.length-secondChainIncludedAmount-1; i>=0; --i){\r\n                    this.visualization.chain2.push({\r\n                        index: currentIndex,\r\n                        residue: ResidueMetaFromResidue(second.residues[i]),\r\n                        interactions: second.residues[i].interactions,\r\n                    });\r\n                    currentIndex++;\r\n                    secondChainIncludedAmount++;\r\n                }\r\n            }\r\n\r\n        }\r\n        // RNA\r\n        else{\r\n            this.visualization.chain1 = [];\r\n            this.visualization.chain2 = null;\r\n            // TODO\r\n        }\r\n\r\n        return this.visualization;\r\n    }\r\n\r\n    // Compares residue centers of nucleic acid and proteins If distance\r\n    // between centers is smaller than defined THRESHOLD_DISTANCE times 2,\r\n    // we can try to search for THRESHOLD_DISTANCE distance between\r\n    // nucleic acid and protein residue atoms\r\n    thresholdInteractions(){\r\n        this.nucleicAcids.forEach((nacid, nacidI)=>{\r\n            nacid.residues.forEach((nacidResidue, nacidResidueI)=>{\r\n                this.proteins.forEach(p=>{\r\n                    p.residues.forEach(pResidue=>{\r\n                        const distanceResidues = distanceBetween2Points(nacidResidue.center, pResidue.center);\r\n\r\n                        // Residues might contain atoms that are less than\r\n                        // THRESHOLD_DISTANCE amount apart even if\r\n                        // residues themselves are 2 times further.\r\n                        if(distanceResidues <= THRESHOLD_DISTANCE*2){\r\n                            nacidResidue.atoms.forEach(nacidAtom=>{\r\n                                pResidue.atoms.forEach(pAtom=>{\r\n                                    const distanceAtoms = distanceBetween2Points(nacidAtom.coords, pAtom.coords);\r\n                                    if(distanceAtoms <= THRESHOLD_DISTANCE){\r\n\r\n                                        this.nucleicAcids[nacidI].residues[nacidResidueI].interactions.push({\r\n                                            residue:ResidueMetaFromResidue(pResidue),\r\n                                            type: InteractionType.Threshold,\r\n                                            polymerKind: p.kind,\r\n                                            meta: {distance:distanceAtoms},\r\n                                        })\r\n                                    }\r\n                                });\r\n                            });\r\n                        }\r\n                    });\r\n                });\r\n            });\r\n        });\r\n    }\r\n}","import React, { useContext, useEffect } from \"react\";\r\nimport * as d3 from 'd3'\r\nimport { Atom, Polymer, Residue, PolymerKind, ResidueMeta, DNAResidues, RNAResidues } from \"../lib/types/atoms\";\r\nimport {context} from '../Store';\r\nimport { InteractionsFinder } from \"../lib/InteractionsFinder\";\r\nimport { VisualizationResidue } from \"../lib/types/visualization\";\r\nimport { Interaction } from \"../lib/types/interactions\";\r\n\r\ninterface D3Element {\r\n    x: number,\r\n    y: number,\r\n    data: ResidueMeta,\r\n    chainId: string,\r\n    visualizationResidue: VisualizationResidue,\r\n}\r\n\r\nexport function Viewer() {\r\n    const [state, dispatch] = useContext(context)\r\n    const polymers = state.polymers;\r\n\r\n    let ref = React.createRef<SVGSVGElement>()\r\n    let tooltip = React.createRef<HTMLDivElement>()\r\n\r\n    // Construct atoms from polymers that are either DNA or RNA, as we only visualize these\r\n    const atoms: Atom[] = [];\r\n    polymers.filter((p)=>[PolymerKind.DNA, PolymerKind.RNA].indexOf(p.kind)!==-1)\r\n        .map(({residues})=>{\r\n            residues.map((r)=>atoms.push(...r.atoms))\r\n        })\r\n\r\n    function initD3(){\r\n        if(!ref || polymers.length <= 0){\r\n            return;\r\n        }\r\n\r\n        // TODO Add RNA colors\r\n        type cmap = {\r\n            [key in DNAResidues]: string\r\n        };\r\n        const ColorMap: cmap = {\r\n            [DNAResidues.DA]: \"#00897b\",\r\n            [DNAResidues.DT]: \"#c2185b\",\r\n            [DNAResidues.DG]: \"#3949ab\",\r\n            [DNAResidues.DC]: \"#ffa000\",\r\n        }\r\n        const GetColor = (r: ResidueMeta): string=>{\r\n            if(r.name in DNAResidues){\r\n                return ColorMap[r.name as DNAResidues];\r\n            }\r\n            return \"#95fe44\";\r\n        };\r\n        const GetHoverColor = (r: ResidueMeta): string=>{\r\n            return \"#95fe44\";\r\n        };\r\n\r\n        // Clean up svg initially\r\n        d3.select(ref.current).selectAll('*').remove();\r\n\r\n        // Start generating new chart\r\n\r\n        // Width and height of svg\r\n        const [w, h] = [900,500];\r\n        // Margins x and y\r\n        const [mX, mY] = [200, 40];\r\n\r\n        const iFinder = new InteractionsFinder(polymers, dispatch);\r\n\r\n        const visualizationData = iFinder.generateVisualizationScaffold();\r\n        let nucleoAcidsData:D3Element[] = []; \r\n\r\n        // Visualization not initialized\r\n        if(visualizationData.chain1 === null){\r\n            return \r\n        }\r\n\r\n        visualizationData?.chain1.forEach(r => {\r\n            nucleoAcidsData.push({ x: 0, y: r.index, data: r.residue, chainId: r.residue.polymerChainIdentifier, visualizationResidue:r})\r\n        });\r\n\r\n        if(visualizationData.chain2!==null){\r\n            visualizationData.chain2.forEach(r => {\r\n                nucleoAcidsData.push({ x: 1, y: r.index, data: r.residue, chainId: r.residue.polymerChainIdentifier, visualizationResidue:r})\r\n            });\r\n        }\r\n        \r\n\r\n        let maxResidues = Math.max(visualizationData.chain1.length, (visualizationData.chain2!== null?visualizationData.chain2.length:0))\r\n        let numAcids = visualizationData.chain2 !== null?2:1;\r\n\r\n        let yScale = d3.scaleLinear()\r\n            .domain([0, maxResidues])\r\n            .range([0+mY, h-mY]);\r\n\r\n        let xScale = d3.scaleLinear()\r\n            .domain([0, numAcids])\r\n            .range([0+mX, w-mX]);\r\n\r\n        const rSize = 10;\r\n    \r\n        const tooltipEl = d3.select(tooltip.current)\r\n        const svg = ref.current\r\n        const chart =  d3.select(svg)\r\n            .attr('width', w)\r\n            .attr('height', h)\r\n            .selectAll()\r\n            .data(nucleoAcidsData)\r\n                .enter()\r\n                .append('circle')\r\n                .attr('cx', (a:any)=>xScale(a.x))\r\n                .attr('cy', (a:any)=>yScale(a.y))\r\n                .style('fill', function(residue:D3Element){\r\n                    return GetColor(residue.data);\r\n                })\r\n                .attr('r', rSize)\r\n                .on('mouseover', async function( event:MouseEvent, residue:D3Element){\r\n                    d3.select(this).attr('r', 15)\r\n                        .style('fill', function(){\r\n                            return GetHoverColor(residue.data);\r\n                        });\r\n                    \r\n                    let b = residue.data as Residue\r\n\r\n                    try{\r\n\r\n                        let interactionsHtml = \"<div><b>Interactions</b></div>\";\r\n                        residue.visualizationResidue.interactions.forEach((i:Interaction)=>{\r\n                            interactionsHtml += `<div>${i.polymerKind}:${i.residue.name+\":\"+i.residue.sequenceNumber} ${i.meta?.distance}</div>`;\r\n                        });\r\n\r\n                        await tooltipEl\r\n                        .html(`<div>Residue: ${b.name} seqno: ${b.sequenceNumber} ChainID: ${residue.chainId}</div>${interactionsHtml}`)\r\n                        .transition()\r\n                        .duration(50)\r\n                        .style('left', event.pageX+\"px\")\r\n                        .style('top', event.pageY+\"px\")\r\n                        .end();\r\n                    }catch(e){\r\n                        console.log(\"Something went wrong: \",e);\r\n                    }\r\n\r\n                    tooltipEl.style('opacity', 1)\r\n                })\r\n                .on('mouseout', function(event:MouseEvent, residue:D3Element){\r\n                    tooltipEl.style('opacity', 0)\r\n                    d3.select(this).attr('r', rSize)\r\n                    .style('fill', function(){\r\n                        return GetColor(residue.data);\r\n                    })\r\n                });\r\n                \r\n\r\n        // const x = atoms.map(a=>a.coords.x)\r\n        // const y = atoms.map(a=>a.coords.y)\r\n        // const z = atoms.map(a=>a.coords.z)\r\n\r\n            \r\n        \r\n        // const tooltipEl = d3.select(tooltip.current)\r\n\r\n        // const rSize = 3;\r\n        // const chart = d3.select(ref.current)\r\n        //     .attr('width', w)\r\n        //     .attr('height', h)\r\n        //     .selectAll('circle')\r\n        //     .data(atoms)\r\n        //     .enter()\r\n        //         .append('circle')\r\n        //         .attr('cx', (a:Atom)=>xScale(a.coords.x))\r\n        //         .attr('cy', (a:Atom)=>yScale(a.coords.y))\r\n        //         .style('fill', '#867')\r\n        //         .on('mouseover', async function( event:MouseEvent, atom:Atom){\r\n        //             d3.select(this).attr('r', 15)\r\n        //                 .style('fill', '#5ef');\r\n\r\n        //             try{\r\n        //                 await tooltipEl\r\n        //                 .html(`Residue: ${atom.residueName} Atom name: ${atom.name} Atom element: ${atom.element}`)\r\n        //                 .transition()\r\n        //                 .duration(50)\r\n        //                 .style('left', event.pageX+\"px\")\r\n        //                 .style('top', event.pageY+\"px\")\r\n        //                 .end();\r\n        //             }catch(e){\r\n        //                 console.log(\"Something went wrong: \",e);\r\n        //             }\r\n\r\n        //             tooltipEl.style('opacity', 1)\r\n        //         })\r\n        //         .on('mouseout', function(d:Atom){\r\n        //             tooltipEl.style('opacity', 0)\r\n        //             d3.select(this).attr('r', rSize)\r\n        //             .style('fill', '#867')\r\n        //         });\r\n\r\n        // chart.transition()\r\n        //     .attr('r', rSize)\r\n        //     .delay(function(a: Atom, i){\r\n        //         return i * 5\r\n        //     })\r\n        //     .duration(500)\r\n    }\r\n\r\n    useEffect(initD3, [polymers])\r\n\r\n    return (\r\n        <>\r\n            <div>\r\n                {state.simpleStuffy}\r\n            </div>\r\n            <div className=\"p-5 flex items-center flex-col\">\r\n                <div>Total number of atoms: {atoms.length}</div>\r\n                <svg ref={ref}></svg>\r\n                <div ref={tooltip} style={{position:\"absolute\", opacity:0, background:\"#fff\"}}></div>\r\n            </div>\r\n        </>\r\n    );  \r\n}","import { Atom, DNAResidues, PDBFile, Polymer, PolymerKind, polymerKindFromAtom, Residue, RNAResidues } from \"./types/atoms\"\r\nimport hash from 'object-hash';\r\n\r\nexport class PDBHandler{\r\n    file?: File\r\n\r\n    constructor(file?: File){\r\n        if (file !== undefined){\r\n            this.file = file\r\n        }\r\n    }\r\n\r\n    async readData(): Promise<PDBFile>{\r\n        if(this.file == undefined){\r\n            throw Error(\"file not provided\");\r\n        }\r\n        let text = await this.file.text()\r\n        return this.format(text)\r\n    }\r\n\r\n    format(text: string): PDBFile{\r\n        return {\r\n            raw: this.formatText(text),\r\n            polymers: this.formatPolymers(text)\r\n        }\r\n    }\r\n\r\n    formatText(text: string): string{\r\n        return text.split('\\n')\r\n            .map((line, index)=>index.toString()+\". \"+line)\r\n            .join(\"\\n\")\r\n    }\r\n\r\n    /**\r\n     * formatAtoms parses PDB strting into Polymer[] data structure\r\n     * \r\n     * PDB File keywords:\r\n     * ATOM - atom information\r\n     * TER - terminates sequence of previously provided ATOMs\r\n     * \r\n     * @param text \r\n     * @returns \r\n     */\r\n    formatPolymers(text: string): Polymer[]{\r\n        let result: Polymer[] = [];\r\n\r\n        // Helper functions to quickly create objects\r\n        const newPolymer = ():Polymer=>{\r\n            return {\r\n                chainIdentifier: '',\r\n                residues: [],\r\n                kind:PolymerKind.Unknown,\r\n            }\r\n        }\r\n        const newResidue = ():Residue=>{\r\n            return {\r\n                atoms: [],\r\n                name: '',\r\n                sequenceNumber: -1,\r\n                center: {\r\n                    x:-1,y:-1,z:-1\r\n                },\r\n                hash:\"\",\r\n                interactions:[],\r\n                polymerChainIdentifier:\"\",\r\n            }\r\n        }\r\n        // Helper to push currentResidue to currentPolymer\r\n        const pushResidue = ():void=>{\r\n            currentResidue.hash = hash(currentResidue);\r\n            currentPolymer.residues.push(currentResidue);\r\n        }\r\n        \r\n        let currentPolymer = newPolymer()\r\n        let currentResidue = newResidue()\r\n\r\n        // Polymer kind determination functionality\r\n        type currentPolymerKind = {\r\n            [key in PolymerKind|number|string]:number\r\n        };\r\n        // Realistically - there should be only 1 PolymerKind for given polymer, but in case it is not, we can\r\n        // check which kind appears more often than others to determine true PolymerKind.\r\n        const determinePolymerKindAndReset = (c?:currentPolymerKind): [currentPolymerKind, PolymerKind] | currentPolymerKind=>{\r\n            let obj = {\r\n                [PolymerKind.DNA]:0,\r\n                [PolymerKind.RNA]:0,\r\n                [PolymerKind.Protein]:0           \r\n            }\r\n            if(c===undefined){\r\n                return obj;\r\n            }\r\n            return [\r\n                obj, // reset obj\r\n                // Get the PolymerKind that has the largest number of occurrences\r\n                Object.keys(c).reduce((a:any,b:any)=>c[a]>c[b]?a:b) as unknown as PolymerKind\r\n            ]\r\n        }\r\n        let currentPolymerKindCounter = determinePolymerKindAndReset() as currentPolymerKind;\r\n\r\n        // Here we will process the pdb text\r\n        text.split(\"\\n\").forEach(line=>{\r\n            // Parse ATOM lines\r\n            if(line.startsWith(\"ATOM\")){\r\n                // https://www.cgl.ucsf.edu/chimera/docs/UsersGuide/tutorials/pdbintro.html\r\n                let x = parseFloat(line.slice(30, 38).trim());\r\n                let y = parseFloat(line.slice(38, 46).trim());\r\n                let z = parseFloat(line.slice(46, 54).trim());\r\n\r\n                let name = line.slice(12,16).trim();\r\n                let residueName = line.slice(17, 20).trim()\r\n                let element = line.slice(76,78).trim();\r\n                let residueSequenceNumber = parseInt(line.slice(22,26).trim());\r\n\r\n                // Chain identifier for current polymer is 1 letter\r\n                let chainIdentifier = line.slice(21,22);\r\n                currentPolymer.chainIdentifier = chainIdentifier;\r\n\r\n                // Construct new atom entry\r\n                const atom: Atom = {\r\n                    coords:{\r\n                        x,y,z\r\n                    },\r\n                    name,\r\n                    element,\r\n                    residueName,\r\n                    residueSequenceNumber,\r\n                }\r\n                \r\n                // Increment probable polymer kind from residue\r\n                currentPolymerKindCounter[polymerKindFromAtom(atom)]++\r\n\r\n                // Set residue sequence number and residue name for first time\r\n                if (currentResidue.sequenceNumber === -1){\r\n                    currentResidue.name = atom.residueName;\r\n                    currentResidue.sequenceNumber = residueSequenceNumber;\r\n                    currentResidue.polymerChainIdentifier = chainIdentifier;\r\n                }\r\n\r\n                // If residue sequence number does not match with current atom's - add residue to polymer and reset currentResidue to a new one\r\n                if (residueSequenceNumber !== currentResidue.sequenceNumber){\r\n                    pushResidue();\r\n                    currentResidue = newResidue();\r\n                    currentResidue.name = atom.residueName;\r\n                    currentResidue.sequenceNumber = residueSequenceNumber;\r\n                    currentResidue.polymerChainIdentifier = chainIdentifier;\r\n                }\r\n\r\n                currentResidue.atoms.push(atom)\r\n            }   \r\n            // TER indicates the end of current polymer (chain of residues)\r\n            if(line.startsWith(\"TER\")){\r\n                // Don't forget to push residue\r\n                pushResidue();\r\n\r\n                // Get polymer kind and reset counter\r\n                let [c, kind] = determinePolymerKindAndReset(currentPolymerKindCounter) as [currentPolymerKind, PolymerKind]\r\n                currentPolymerKindCounter = c;\r\n                currentPolymer.kind = kind;\r\n\r\n                // Save polymer\r\n                result.push(currentPolymer);\r\n\r\n                // Reset current polymer and residue\r\n                currentPolymer = newPolymer();\r\n                currentResidue = newResidue();\r\n            }\r\n        });\r\n        \r\n        return result;\r\n    }\r\n\r\n}","import React, { useState, ChangeEventHandler, ChangeEvent, useEffect, useContext } from \"react\";\r\nimport { InteractionsFinder } from \"../lib/InteractionsFinder\";\r\nimport { PDBHandler } from \"../lib/PDBHandler\";\r\nimport { PDBFile, Polymer } from \"../lib/types/atoms\";\r\nimport {context, Action} from '../Store';\r\n\r\n\r\n\r\n// Fetch PDB text for given id (if valid)\r\nconst fetchPDBFile = async (id:string):Promise<string>=>{\r\n    const response = await fetch(`https://files.rcsb.org/download/${id}.pdb`);\r\n    const pdbText = await response.text();\r\n    return pdbText;\r\n}\r\n\r\nexport function DataFetcher(){\r\n    const [state, dispatch] = useContext(context)\r\n\r\n    const startLoading = ()=>{\r\n        dispatch({\r\n            type: 'isLoading',\r\n            payload: true,\r\n        });\r\n    };\r\n    const stopLoading = ()=>{\r\n        dispatch({\r\n            type: 'isLoading',\r\n            payload: false,\r\n        });\r\n    }\r\n    const updatePDBState = (pdb:PDBFile)=>{\r\n        dispatch({\r\n            type:'pdb',\r\n            payload:pdb,\r\n        });\r\n    }\r\n    // Update polymers in store, generate visualization data structure\r\n    const updatePolymers = (polymers: Polymer[])=>{\r\n        dispatch({\r\n            type:'polymers',\r\n            payload: polymers\r\n        });\r\n\r\n        const iFinder = new InteractionsFinder(polymers, dispatch);\r\n        \r\n        // Load all needed interactions\r\n        iFinder.thresholdInteractions()\r\n\r\n        // Generate visualization data structure\r\n        dispatch({\r\n            type:'viz',\r\n            payload: iFinder.generateVisualizationScaffold()\r\n        })\r\n    };\r\n\r\n\r\n    // Fetch PDB file by given id parameter. Must run only once\r\n    useEffect(()=>{\r\n        const url = new URLSearchParams(window.location.search);\r\n        const id = url.get('id');\r\n        console.log(\"ID\", id)\r\n        if (id !== null){\r\n             (async()=>{\r\n                startLoading();\r\n                const pdb = new PDBHandler().format(\r\n                    await fetchPDBFile(id)\r\n                );\r\n                updatePDBState(pdb);\r\n                updatePolymers(pdb.polymers);\r\n                stopLoading();\r\n            })()\r\n        }    \r\n    }, []);\r\n\r\n    // Updates pbd file information from uploaded file, parses pdb data and performs interaction calculations\r\n    const handleFileChange: ChangeEventHandler<HTMLInputElement> = async (event: ChangeEvent)=>{\r\n        let f = (event.target as HTMLInputElement).files?.item(0);\r\n        if(f !== null){\r\n            // Show spinner while loading\r\n            startLoading();\r\n\r\n            // Read and parse the file\r\n            console.time(\"TIME_TO_PARSE_EVERYTHING\");\r\n            console.time(\"TIME_TO_PARSE_PDB\");\r\n            const pdb = await new PDBHandler(f as File).readData()\r\n            console.timeEnd(\"TIME_TO_PARSE_PDB\");\r\n            \r\n            // Update state with parsed values\r\n            updatePDBState(pdb);\r\n            updatePolymers(pdb.polymers);\r\n\r\n            // Some fake loading time, so we get to see the spinner :)\r\n            console.timeEnd(\"TIME_TO_PARSE_EVERYTHING\");\r\n            setTimeout(stopLoading, 2000)\r\n        }\r\n    }\r\n\r\n    let pdbText: JSX.Element|undefined;\r\n    if(state.polymers.length > 0){\r\n        pdbText = (\r\n            <div className=\"mt-5\">\r\n                <div className=\"mb-1\">Provided input file</div>\r\n                <textarea className=\"text-sm w-full border h-96 border-blue-100\" value={state.pdb?.raw} readOnly/>\r\n            </div>\r\n        )\r\n    }\r\n\r\n    // Render data fetcher box\r\n    return (\r\n        <div className=\"p-5 max-h-screen overflow-auto break-words\">\r\n            {!state.isLoading &&\r\n                <div>\r\n                    { state.pdb === undefined &&\r\n                        <div className=\"text-sm text-gray-600 mb-4 bg-red-200 p-2\">\r\n                            Choose a PDB file which contains DNA/RNA with Proteins\r\n                        </div>\r\n                    }\r\n                    <div>\r\n                        <input type=\"file\" onChange={handleFileChange}/> \r\n                    </div>\r\n                </div>\r\n            }\r\n            {pdbText}\r\n            {(state.pdb)&&\r\n                <div>\r\n                   Polymers from input: \r\n                   {state.polymers.map(({residues, chainIdentifier, kind}, k)=>\r\n                       <div className=\"ml-2\" key={k}>\r\n                            Chain: <b>{chainIdentifier} ({kind})</b>\r\n                            <div className=\"ml-2\">\r\n                                {residues.map(\r\n                                    (residue, key)=>{\r\n                                        return <span key={key}>{residue.name} &nbsp;</span> \r\n                                    })\r\n                                }\r\n                            </div>\r\n                       </div>\r\n                   )}\r\n                </div>\r\n            }\r\n        </div>\r\n    );\r\n}","import \"./../css/spinner.css\"\r\n\r\nconst Spinner = ()=>{\r\n    return (\r\n        <div className=\"lds-roller\"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div>\r\n    );\r\n}\r\n\r\nexport default Spinner;\r\n\r\n","import React, { useEffect, useState, useContext, ReactElement, Children } from 'react';\r\nimport { Viewer } from './components/Viewer';\r\nimport { DataFetcher } from './components/DataFetcher';\r\nimport Spinner from './components/Spinner';\r\nimport {StoreComponent, context} from './Store'\r\n\r\nexport function App() {\r\n  const state = useContext(context)[0];\r\n\r\n  return (\r\n      <div className=\"w-full flex flex-row\">\r\n        {(state.isLoading === true) &&\r\n          <div className=\"fixed w-screen min-h-screen top-0 left-0 flex items-center justify-center z-50\" style={{backgroundColor:\"rgba(0,0,0,0.35)\"}}>\r\n            <Spinner/>\r\n          </div>\r\n        }\r\n        <div className=\"z-10 w-9/12 bg-indigo-300 min-h-full h-screen\">\r\n          <Viewer/>\r\n        </div>\r\n        <div className=\"z-10 w-3/12\">\r\n          <DataFetcher/>\r\n        </div>\r\n      </div>\r\n  );\r\n}\r\n\r\ninterface Props{\r\n  children: ReactElement,\r\n}\r\n\r\n// We want to provide nice loading animation at the top level.\r\n// So this wrapper simply allows App to use context state.\r\nexport function AppWrapper({children}:Props){\r\n  return (\r\n    <StoreComponent>{children}</StoreComponent>\r\n  );\r\n}\r\n","import { ReportHandler } from 'web-vitals';\r\n\r\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\r\n  if (onPerfEntry && onPerfEntry instanceof Function) {\r\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\r\n      getCLS(onPerfEntry);\r\n      getFID(onPerfEntry);\r\n      getFCP(onPerfEntry);\r\n      getLCP(onPerfEntry);\r\n      getTTFB(onPerfEntry);\r\n    });\r\n  }\r\n};\r\n\r\nexport default reportWebVitals;\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport {App, AppWrapper} from './App';\r\nimport reportWebVitals from './reportWebVitals';\r\n\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <AppWrapper>\r\n      <App/>\r\n    </AppWrapper>\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n\r\n// If you want to start measuring performance in your app, pass a function\r\n// to log results (for example: reportWebVitals(console.log))\r\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\r\nreportWebVitals();\r\n"],"sourceRoot":""}